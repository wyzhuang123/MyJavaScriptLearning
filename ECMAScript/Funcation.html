<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
</body>
<script>


    var sum=function(num1,num2){
      return num1+num2;
    }
    console.log(sum(10,20)); 
    var othersum=sum;
    // sum=null; //如果是引用，othersum =null
    //函数名sum只是一个指针
    console.log(othersum(10,30)); 
    console.log(sum(10,40)); 
    

    /*
    函数声明与函数表达式
    */
    
    console.log(doing(10,20));
    function doing(num1,num2){
      return num1*num2
    }

    /*
    函数声明
    1.function doing
    2.doing=return ...
    3.log
    在java中不可能的
    */

    /*
    函数表达式没有函数的提前声明
    变量定义中也是存在的
    */
    // console.log(dodo(20,10));
    // var dodo=function(num1,num2){
    //   return num1-num2;  //报错
    // }


    /*
    函数内部属性
    arguments.callee(),避免了函数内部调用的函数名耦合，即使是换了函数名
    也不会出错
    */
    function foo(num){
      if(num<=1){
        return 1;
      }else{
        return num*arguments.callee(num-1);
      }
    }
    console.log(foo(5));
    var foo2=foo;
    foo=null;
    console.log(foo2(5));

    /*
    函数的另一个this，this引用的是函数据以执行的环境对象
    函数的名字仅仅是一个包含指针的变量而已，即使在不同环境执行，
    仍然是那一个
    */



    /*
    函数属性和方法
    1.length 2.prototype
    length表示的是函数的参数个数
    */
      var abc=function(a,b){
        return a+b;
      }
      console.log(abc.length);

    /*
    prototype的属性是不可枚举的，不法用for in遍历
    */
      console.log(abc.prototype);
      
    /*
    constructor: ƒ (a,b)
     [[Prototype]]: Object   prototype的属性
     constructor: ƒ Object()
     hasOwnProperty: ƒ hasOwnProperty()
     isPrototypeOf: ƒ isPrototypeOf()
     propertyIsEnumerable: ƒ propertyIsEnumerable()
     toLocaleString: ƒ toLocaleString()
     toString: ƒ toString()
     valueOf: ƒ valueOf()
     __defineGetter__: ƒ __defineGetter__()
     __defineSetter__: ƒ __defineSetter__()
     __lookupGetter__: ƒ __lookupGetter__()
     __lookupSetter__: ƒ __lookupSetter__()
     get __proto__: ƒ __proto__()
     set __proto__: ƒ __proto__()
    */




     /*
     每个函数都包含两个非继承而来的方法，call()和apply()
     */ 
      window.color="red";
      var a=14;
      var b=15;
      var o={
        color:"blue",
        sum:function(num1,num2){
            num1=20;
            num2=30;
            return num1+num2;
        }
      };
      // function oo(){
      //   var a=20;
      //   var b=30;
      //   var c=function(num1,num2){
      //     return a*b;
      //   }
      // }
      function sayColor(){
        console.log(this.color);
      }
      function sum(num1,num2){
        return num1*num2;
      }
      sayColor();
      sayColor.call(this)
      sayColor.call(window)
      //将this绑定给o时，color输出为blue
      // sayColor.call(o)  
      console.log(sum(a,b));
      console.log(o.sum.call(window,a,b));

      /*
      bind()
      */
      window.job="teacher";
      var o={job:"doctor"}

      function sayJob(){
        console.log(this.job);
      }
      //otherJob指针指向sayJob函数，而且this指向的时o对象
      var otherJob=sayJob.bind(o);
      sayJob();
      otherJob();












</script>
</html>